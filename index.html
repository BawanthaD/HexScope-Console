<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Device Console</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #020617;
      color: #e5e7eb;
      margin: 0;
      padding: 16px;
    }
    h1 {
      margin-top: 0;
      font-size: 1.4rem;
    }
    .grid {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 3fr);
      gap: 16px;
    }
    .panel {
      border: 1px solid #374151;
      border-radius: 8px;
      padding: 12px 16px;
      background: #020617;
      margin-bottom: 16px;
    }
    .panel h2 {
      margin: 0 0 8px 0;
      font-size: 1rem;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    label {
      font-size: 0.9rem;
      margin-right: 4px;
    }
    select, input, button {
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #4b5563;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.9rem;
      font-family: inherit;
    }
    button {
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    textarea {
      width: 100%;
      height: 200px;
      resize: vertical;
      font-family: monospace;
      font-size: 0.8rem;
      line-height: 1.3;
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #4b5563;
      border-radius: 4px;
      padding: 6px;
    }
    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 4px;
      background: #ef4444;
    }
    .status-dot.connected {
      background: #22c55e;
    }
    .small {
      font-size: 0.8rem;
      color: #9ca3af;
    }
    .pill {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: #111827;
      border: 1px solid #4b5563;
      margin-right: 4px;
    }
    .decoded-item {
      font-size: 0.85rem;
      border-bottom: 1px solid #1f2937;
      padding: 4px 0;
    }
    canvas {
      background: #020617;
    }
  </style>
</head>
<body>
  <h1>Device Console (Browser + Web Serial)</h1>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Connection -->
  <div class="panel">
    <div class="row">
      <span id="status">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusText">Disconnected</span>
      </span>
    </div>
    <div class="row">
      <label for="baudRate">Baud rate:</label>
      <select id="baudRate">
        <option value="9600">9600</option>
        <option value="19200">19200</option>
        <option value="38400">38400</option>
        <option value="57600">57600</option>
        <option value="115200" selected>115200</option>
        <option value="230400">230400</option>
        <option value="460800">460800</option>
        <option value="921600">921600</option>
      </select>

      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
    </div>
    <div class="small">
      Use Chrome / Edge with Web Serial. Serve this as http://localhost/... (not file://).
    </div>
  </div>

  <div class="grid">
    <!-- Left side: controls + graph + decoded -->
    <div>
      <!-- Variable controls -->
      <div class="panel">
        <h2>Variables</h2>
        <div class="row">
          <label for="varSelect">Variable:</label>
          <select id="varSelect"></select>
        </div>
        <div class="row">
          <button id="readVarBtn" disabled>Read variable</button>
        </div>
        <div class="row">
          <label for="writeValue">Write value:</label>
          <input type="number" id="writeValue" style="width: 120px;">
          <button id="writeVarBtn" disabled>Write variable</button>
        </div>
        <div class="row">
          <button id="notifyStartBtn" disabled>Start notify</button>
          <button id="notifyStopBtn" disabled>Stop notify (selected)</button>
        </div>
        <div class="small">
          Click <b>Start notify</b> for each variable you want to stream.<br>
          <b>Stop notify</b> sends NOTIFY_STOP for the currently selected variable.
        </div>
      </div>

      <!-- Graph panel -->
      <div class="panel">
        <h2>Live Plot</h2>
        <div class="row" id="plotVarContainer">
          <!-- checkboxes populated by JS -->
        </div>
        <canvas id="dataChart" height="200"></canvas>
        <div class="small">
          Each variable is its own trace (x = time, y = value). Checkboxes show/hide traces.
        </div>
      </div>

      <!-- Decoded frames -->
      <div class="panel">
        <h2>Decoded Frames</h2>
        <div id="decodedList" class="small">
          <!-- populated by JS -->
        </div>
      </div>
    </div>

    <!-- Right side: Raw logs -->
    <div>
      <div class="panel">
        <div class="row">
          <h2 style="margin:0;">Raw RX (hex)</h2>
          <button id="clearRxBtn" style="margin-left:auto;">Clear</button>
        </div>
        <textarea id="rxLog" readonly></textarea>
      </div>
    </div>
  </div>

  <script>
    /************************************************************
     *  Protocol definition
     ************************************************************/
    const SOF = 0xAA;
    const EOF = 0x55;

    const CMD_READ_VAR       = 0x01;
    const CMD_WRITE_VAR      = 0x02;
    const CMD_NOTIFY_START   = 0x03;
    const CMD_NOTIFY_STOP    = 0x04;

    const CMD_READ_RESPONSE  = 0x81;
    const CMD_NOTIFY_DATA    = 0x82;

    // Example variable database
    const VARIABLE_DB = [
      { id: 0x10, name: 'Temperature', type: 'int16', unit: '°C' },
      { id: 0x11, name: 'Pressure',    type: 'int16', unit: 'kPa' },
      { id: 0x12, name: 'Flow Rate',   type: 'int16', unit: 'L/min' },
    ];

    function getVarById(id) {
      return VARIABLE_DB.find(v => v.id === id);
    }

    function getVarByName(name) {
      return VARIABLE_DB.find(v => v.name === name);
    }

    // CRC: XOR of bytes from LEN..payload end
    function calcCRC(bytes, startIndex, endIndexInclusive) {
      let crc = 0;
      for (let i = startIndex; i <= endIndexInclusive; i++) {
        crc ^= bytes[i];
      }
      return crc & 0xFF;
    }

    // Build frame: SOF | LEN | TYPE | PAYLOAD... | CRC | EOF
    // LEN = TYPE + PAYLOAD length
    function buildFrame(type, payloadBytes) {
      const len = 1 + payloadBytes.length;
      const frameLen = 1 + 1 + len + 1 + 1;
      const frame = new Uint8Array(frameLen);

      let i = 0;
      frame[i++] = SOF;
      frame[i++] = len;
      frame[i++] = type;
      for (const b of payloadBytes) {
        frame[i++] = b;
      }
      const crc = calcCRC(frame, 1, i - 1);
      frame[i++] = crc;
      frame[i++] = EOF;
      return frame;
    }

    function buildReadVarFrame(varId) {
      return buildFrame(CMD_READ_VAR, [varId]);
    }

    function buildWriteVarFrame(varId, valueInt16) {
      const v = valueInt16 & 0xFFFF;
      const lo = v & 0xFF;
      const hi = (v >> 8) & 0xFF;
      return buildFrame(CMD_WRITE_VAR, [varId, lo, hi]);
    }

    function buildNotifyStartFrame(varId) {
      return buildFrame(CMD_NOTIFY_START, [varId]);
    }

    function buildNotifyStopFrame(varId) {
      return buildFrame(CMD_NOTIFY_STOP, [varId]);
    }

    /************************************************************
     *  Parsing RX frames
     ************************************************************/
    let rxBuffer = [];

    function handleIncomingBytes(chunk) {
      for (const b of chunk) rxBuffer.push(b);
      logRawHex(chunk);
      parseFramesFromBuffer();
    }

    function parseFramesFromBuffer() {
      const MIN_FRAME = 5;

      while (rxBuffer.length >= MIN_FRAME) {
        const sofIndex = rxBuffer.indexOf(SOF);
        if (sofIndex === -1) {
          rxBuffer = [];
          return;
        }
        if (sofIndex > 0) {
          rxBuffer = rxBuffer.slice(sofIndex);
        }
        if (rxBuffer.length < MIN_FRAME) return;

        const len = rxBuffer[1];
        const totalFrameLen = 1 + 1 + len + 1 + 1;
        if (rxBuffer.length < totalFrameLen) return;

        const frame = rxBuffer.slice(0, totalFrameLen);
        rxBuffer = rxBuffer.slice(totalFrameLen);

        if (frame[frame.length - 1] !== EOF) {
          console.warn('Bad EOF', frame);
          continue;
        }

        const crcReceived = frame[frame.length - 2];
        const crcComputed = calcCRC(frame, 1, frame.length - 3);
        if (crcReceived !== crcComputed) {
          console.warn('CRC mismatch');
          addDecodedItem({ type: 'CRC_ERROR', raw: frame });
          continue;
        }

        const type = frame[2];
        const payload = frame.slice(3, frame.length - 2);
        interpretFrame(type, payload, frame);
      }
    }

    function interpretFrame(type, payload, rawFrame) {
      if ((type === CMD_READ_RESPONSE || type === CMD_NOTIFY_DATA) && payload.length >= 3) {
        const varId = payload[0];
        const lo = payload[1];
        const hi = payload[2];
        let value = (hi << 8) | lo;
        if (value & 0x8000) value = value - 0x10000;
        const v = getVarById(varId);
        const name = v ? v.name : `0x${varId.toString(16)}`;
        const unit = v?.unit || '';

        const kind = (type === CMD_READ_RESPONSE ? 'READ_RESPONSE' : 'NOTIFY_DATA');

        addDecodedItem({
          type: kind,
          varId,
          name,
          value,
          unit,
          raw: rawFrame
        });

        // Feed the graph for every sample
        addChartPoint(varId, value);
      } else {
        addDecodedItem({
          type: 'UNKNOWN',
          raw: rawFrame
        });
      }
    }

    /************************************************************
     *  UI + Serial handling
     ************************************************************/
    let port = null;
    let reader = null;
    let keepReading = false;

    const statusDot     = document.getElementById('statusDot');
    const statusText    = document.getElementById('statusText');
    const connectBtn    = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const baudSelect    = document.getElementById('baudRate');
    const rxLog         = document.getElementById('rxLog');
    const clearRxBtn    = document.getElementById('clearRxBtn');

    const varSelect       = document.getElementById('varSelect');
    const readVarBtn      = document.getElementById('readVarBtn');
    const writeVarBtn     = document.getElementById('writeVarBtn');
    const notifyStartBtn  = document.getElementById('notifyStartBtn');
    const notifyStopBtn   = document.getElementById('notifyStopBtn');
    const writeValue      = document.getElementById('writeValue');
    const decodedList     = document.getElementById('decodedList');
    const plotVarContainer= document.getElementById('plotVarContainer');

    function initVariableDropdownsAndCheckboxes() {
      VARIABLE_DB.forEach((v, idx) => {
        // Control dropdown
        const opt = document.createElement('option');
        opt.value = v.name;
        opt.textContent = `${v.name} (0x${v.id.toString(16)})`;
        varSelect.appendChild(opt);

        // Plot checkbox
        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.gap = '4px';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = (idx === 0); // show first by default
        cb.dataset.varId = v.id;

        cb.addEventListener('change', () => {
          onPlotCheckboxChanged(v.id, cb.checked);
        });

        label.appendChild(cb);
        label.appendChild(document.createTextNode(v.name));
        plotVarContainer.appendChild(label);
      });
    }

    initVariableDropdownsAndCheckboxes();

    function setConnectedState(isConnected, info = '') {
      if (isConnected) {
        statusDot.classList.add('connected');
        statusText.textContent = 'Connected ' + info;
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        readVarBtn.disabled = false;
        writeVarBtn.disabled = false;
        notifyStartBtn.disabled = false;
        notifyStopBtn.disabled = false;
      } else {
        statusDot.classList.remove('connected');
        statusText.textContent = 'Disconnected';
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        readVarBtn.disabled = true;
        writeVarBtn.disabled = true;
        notifyStartBtn.disabled = true;
        notifyStopBtn.disabled = true;
      }
    }

    function logRawHex(chunk) {
      const hexLine = Array.from(chunk)
        .map(b => b.toString(16).padStart(2, '0'))
        .join(' ');
      rxLog.value += hexLine + '\n';
      rxLog.scrollTop = rxLog.scrollHeight;
    }

    function addDecodedItem(info) {
      const div = document.createElement('div');
      div.className = 'decoded-item';

      const rawHex = Array.from(info.raw || [])
        .map(b => b.toString(16).padStart(2, '0'))
        .join(' ');

      if (info.type === 'READ_RESPONSE') {
        div.innerHTML =
          `<span class="pill">READ</span>` +
          `<strong>${info.name}</strong> = ${info.value} ${info.unit} ` +
          `<span class="small">(varId=0x${info.varId.toString(16)})</span><br>` +
          `<span class="small">raw: ${rawHex}</span>`;
      } else if (info.type === 'NOTIFY_DATA') {
        div.innerHTML =
          `<span class="pill">NOTIFY</span>` +
          `<strong>${info.name}</strong> = ${info.value} ${info.unit} ` +
          `<span class="small">(varId=0x${info.varId.toString(16)})</span><br>` +
          `<span class="small">raw: ${rawHex}</span>`;
      } else if (info.type === 'CRC_ERROR') {
        div.innerHTML =
          `<span class="pill">CRC ERROR</span> ` +
          `<span class="small">raw: ${rawHex}</span>`;
      } else {
        div.innerHTML =
          `<span class="pill">${info.type}</span> ` +
          `<span class="small">raw: ${rawHex}</span>`;
      }

      decodedList.prepend(div);
    }

    async function connectSerial() {
      if (!('serial' in navigator)) {
        alert('Web Serial API not supported in this browser.');
        return;
      }
      try {
        port = await navigator.serial.requestPort();
        const baudRate = parseInt(baudSelect.value, 10);
        await port.open({
          baudRate,
          dataBits: 8,
          stopBits: 1,
          parity: 'none',
          flowControl: 'none'
        });

        setConnectedState(true, `(baud ${baudRate})`);
        keepReading = true;
        readLoop();
      } catch (err) {
        console.error('Error opening serial port:', err);
        alert('Failed to open serial port: ' + err);
      }
    }

    async function disconnectSerial() {
      try {
        keepReading = false;
        if (reader) {
          try {
            await reader.cancel();
          } catch (e) {
            console.warn('Error cancelling reader:', e);
          }
          reader.releaseLock();
          reader = null;
        }
        if (port) {
          await port.close();
          port = null;
        }
      } catch (err) {
        console.error('Error closing serial port:', err);
      } finally {
        setConnectedState(false);
      }
    }

    async function readLoop() {
      if (!port.readable) {
        console.warn('Port is not readable');
        return;
      }
      reader = port.readable.getReader();
      try {
        while (keepReading) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value && value.length > 0) handleIncomingBytes(value);
        }
      } catch (err) {
        console.error('Read error:', err);
      } finally {
        if (reader) {
          reader.releaseLock();
          reader = null;
        }
        setConnectedState(false);
      }
    }

    async function sendFrame(frame) {
      if (!port || !port.writable) {
        alert('Not connected');
        return;
      }
      const writer = port.writable.getWriter();
      try {
        await writer.write(frame);
      } catch (err) {
        console.error('Error sending frame:', err);
        alert('Failed to send: ' + err);
      } finally {
        writer.releaseLock();
      }
    }

    async function onReadVariable() {
      const varName = varSelect.value;
      const v = getVarByName(varName);
      if (!v) return;
      const frame = buildReadVarFrame(v.id);
      await sendFrame(frame);
    }

    async function onWriteVariable() {
      const varName = varSelect.value;
      const v = getVarByName(varName);
      if (!v) return;
      const val = parseInt(writeValue.value, 10);
      if (Number.isNaN(val)) {
        alert('Enter a numeric value');
        return;
      }
      const frame = buildWriteVarFrame(v.id, val);
      await sendFrame(frame);
    }

    async function onNotifyStart() {
      const varName = varSelect.value;
      const v = getVarByName(varName);
      if (!v) return;
      const frame = buildNotifyStartFrame(v.id);
      await sendFrame(frame);
    }

    async function onNotifyStop() {
      const varName = varSelect.value;
      const v = getVarByName(varName);
      if (!v) return;
      const frame = buildNotifyStopFrame(v.id);
      await sendFrame(frame);
    }

    connectBtn.addEventListener('click', connectSerial);
    disconnectBtn.addEventListener('click', disconnectSerial);
    clearRxBtn.addEventListener('click', () => { rxLog.value = ''; });

    readVarBtn.addEventListener('click', onReadVariable);
    writeVarBtn.addEventListener('click', onWriteVariable);
    notifyStartBtn.addEventListener('click', onNotifyStart);
    notifyStopBtn.addEventListener('click', onNotifyStop);

    /************************************************************
     *  Chart handling – multiple datasets, scatter-style
     ************************************************************/
    const chartCtx = document.getElementById('dataChart').getContext('2d');
    const MAX_POINTS = 300;

    const t0 = performance.now(); // reference time

    // One dataset per variable, using {x,y} points
    const datasets = VARIABLE_DB.map((v, idx) => ({
      label: v.name,
      data: [],
      borderWidth: 1,
      tension: 0.1,
      pointRadius: 0,
      varId: v.id,
      hidden: idx !== 0,  // show first by default
      parsing: false      // we provide {x,y}
    }));

    const dataChart = new Chart(chartCtx, {
      type: 'line',
      data: {
        datasets: datasets
      },
      options: {
        animation: false,
        responsive: true,
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: 'Time (s)' }
          },
          y: {
            title: { display: true, text: 'Value' }
          }
        },
        plugins: {
          legend: { display: true }
        }
      }
    });

    function onPlotCheckboxChanged(varId, isChecked) {
      const ds = dataChart.data.datasets.find(d => d.varId === varId);
      if (!ds) return;
      ds.hidden = !isChecked;
      dataChart.update();
    }

    function addChartPoint(varId, value) {
      const tNow = (performance.now() - t0) / 1000.0; // seconds since page load

      const ds = dataChart.data.datasets.find(d => d.varId === varId);
      if (!ds) return;

      ds.data.push({ x: tNow, y: value });

      if (ds.data.length > MAX_POINTS) {
        ds.data.shift();
      }

      dataChart.update('none'); // no animation → smooth streaming
    }
  </script>
</body>
</html>
