<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HexScope Console</title>
  <style>
    :root {
      --bg-body: #020617;
      --bg-surface: #0f172a;
      --border-subtle: rgba(148, 163, 184, 0.16);
      --accent: #3b82f6;
      --danger: #ef4444;
      --text-primary: #e5e7eb;
      --text-muted: #94a3b8;
      --radius-lg: 12px;
      --radius-sm: 6px;
      --shadow-soft: 0 18px 40px rgba(15, 23, 42, 0.65);
      --input-bg: #020617;
      --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--font-sans);
      background: radial-gradient(circle at top, #0b1120 0, #020617 40%, #020617 100%);
      color: var(--text-primary);
    }

    /* TOP BAR */
    .topbar {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(12px);
      background: rgba(15, 23, 42, 0.94);
      border-bottom: 1px solid var(--border-subtle);
      padding: 12px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .topbar-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .app-logo {
      width: 26px;
      height: 26px;
      border-radius: 8px;
      background: radial-gradient(circle at 30% 20%, #38bdf8, #1d4ed8 60%, #020617 90%);
      box-shadow: 0 0 18px rgba(59, 130, 246, 0.7);
    }

    .app-title {
      font-size: 1.15rem;
      font-weight: 600;
    }

    .topbar-subtitle {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      border: 1px solid var(--border-subtle);
      background: rgba(15, 23, 42, 0.9);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--danger);
    }

    .status-dot.connected {
      background: #22c55e;
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.6);
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: 0.18s;
    }

    .btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.5);
    }
    .btn-primary:hover:not(:disabled) { background: #2563eb; }

    .btn-outline {
      border: 1px solid var(--border-subtle);
      background: transparent;
      color: var(--text-primary);
    }

    .btn-danger {
      background: #b91c1c;
      color: white;
    }

    select, input[type="number"] {
      background: var(--input-bg);
      border: 1px solid var(--border-subtle);
      color: var(--text-primary);
      padding: 6px 10px;
      border-radius: var(--radius-sm);
      outline: none;
      font-size: 0.85rem;
    }

    /* LAYOUT */
    .page {
      padding: 18px 24px;
      max-width: 1400px;
      margin: auto;
    }

    .grid {
      display: grid;
      grid-template-columns: 1.4fr 2fr;
      gap: 20px;
    }

    .panel {
      background: var(--bg-surface);
      border-radius: var(--radius-lg);
      padding: 18px;
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-soft);
    }

    .panel-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .panel-caption {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    textarea {
      width: 100%;
      height: 200px;
      background: var(--input-bg);
      border: 1px solid var(--border-subtle);
      color: var(--text-primary);
      padding: 8px;
      border-radius: var(--radius-sm);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 0.8rem;
      resize: vertical;
    }

    .latest-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 4px 0;
      border-bottom: 1px dashed rgba(255,255,255,0.08);
      font-size: 0.82rem;
    }

    .latest-row:last-child {
      border-bottom: none;
    }

    canvas {
      background: #020617;
      border-radius: 10px;
    }

    .checkbox-pill {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148,163,184,0.3);
      border-radius: 999px;
      margin: 2px 6px 6px 0;
      font-size: 0.8rem;
      gap: 6px;
      cursor: pointer;
    }

    .checkbox-pill input {
      accent-color: var(--accent);
      cursor: pointer;
    }

    /* Variable rows */
    .var-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      border-bottom: 1px dashed rgba(255,255,255,0.08);
      font-size: 0.82rem;
    }
    .var-row:last-child {
      border-bottom: none;
    }
    .var-row-left {
      display: flex;
      flex-direction: column;
    }
    .var-row-name {
      font-size: 0.86rem;
      font-weight: 500;
    }
    .var-row-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    .var-row-right {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .var-row-right input[type="number"] {
      width: 90px;
      font-size: 0.8rem;
    }
    .var-row-value {
      min-width: 90px;
      text-align: right;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 14px;
      border-bottom: 1px solid var(--border-subtle);
    }
    .tab-btn {
      border: none;
      background: transparent;
      padding: 8px 14px;
      font-size: 0.85rem;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 999px 999px 0 0;
      border-bottom: 2px solid transparent;
      transition: 0.18s;
    }
    .tab-btn.active {
      color: var(--text-primary);
      border-bottom-color: var(--accent);
      background: rgba(15, 23, 42, 0.9);
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- TOP BAR -->
  <header class="topbar">
    <div class="topbar-left">
      <div class="app-logo"></div>
      <div>
        <div class="app-title">HexScope Console</div>
        <div class="topbar-subtitle">
          Hex protocol · Flexible notify · Multi Read/Write · Plot & CSV
        </div>
      </div>
    </div>
    <div style="display:flex; align-items:center; gap:12px;">
      <div class="status-pill">
        <span id="statusDot" class="status-dot"></span>
        <span id="statusText"><strong>Disconnected</strong></span>
      </div>
      <label for="baudRate" style="font-size:0.8rem; color:var(--text-muted);">Baud</label>
      <select id="baudRate">
        <option value="115200" selected>115200</option>
        <option value="57600">57600</option>
        <option value="38400">38400</option>
      </select>
      <button id="connectBtn" class="btn btn-primary">Connect</button>
      <button id="disconnectBtn" class="btn btn-outline btn-danger" disabled>Disconnect</button>
    </div>
  </header>

  <!-- MAIN CONTENT -->
  <main class="page">
    <!-- Tabs -->
    <div class="tabs">
      <button id="tabReadBtn"   class="tab-btn active">Read</button>
      <button id="tabWriteBtn"  class="tab-btn">Write</button>
      <button id="tabNotifyBtn" class="tab-btn">Notify & Monitor</button>
    </div>

    <!-- READ TAB -->
    <section id="tabRead" class="tab-content active">
      <div class="grid">
        <!-- LEFT: Read Variables -->
        <div class="panel">
          <div class="panel-title">Read Variables</div>
          <div class="panel-caption">
            Click <strong>Read</strong> to request a variable. The value shows <code>--</code> until the response arrives.
            If <code>readFormula</code> is defined in <code>variables.json</code>, it will be used for decoding.
            If <code>valueMap</code> is defined, labels such as <code>ON (1)</code> will be shown.
          </div>
          <div id="varTableReadContainer"></div>
          <div style="margin-top:10px;">
            <button id="readAllBtn" class="btn btn-outline" disabled>Read All</button>
          </div>
        </div>

        <!-- RIGHT: Raw RX -->
        <div class="panel">
          <div class="panel-title">Raw RX (Hex)</div>
          <div class="panel-caption">
            Raw bytes received from UART, formatted as hexadecimal (for debugging).
          </div>
          <textarea id="rxLog" readonly></textarea>
          <button id="clearRxBtn" class="btn btn-outline" style="width:100%; margin-top:8px;">
            Clear Raw RX Log
          </button>
        </div>
      </div>
    </section>

    <!-- WRITE TAB -->
    <section id="tabWrite" class="tab-content">
      <div class="grid">
        <!-- LEFT: Write Variables -->
        <div class="panel">
          <div class="panel-title">Write Variables</div>
          <div class="panel-caption">
            Set values for writable variables. Last known value is displayed per row. <br>
            <code>readFormula</code> is ignored for writes; encoding uses <code>format</code>, <code>scale</code>, etc.
            If <code>valueMap</code> is present you’ll still see <code>ON (1)</code> style labels.
          </div>
          <div id="varTableWriteContainer"></div>
          <div style="margin-top:10px; font-size:0.78rem; color:var(--text-muted);">
            Encoding (int16/int32/float32, scaling, signedness) is defined in <code>variables.json</code>.
          </div>
        </div>

        <!-- RIGHT: Info -->
        <div class="panel">
          <div class="panel-title">Info</div>
          <div class="panel-caption">
            This panel is reserved for future write-related tools (batch write, templates, etc.).
          </div>
          <p style="font-size:0.85rem; color:var(--text-muted);">
            For now, use the left panel to write individual variables. Values written here also appear in the
            <strong>Notify &amp; Monitor</strong> tab if those variables are plotted or shown in Latest Values.
          </p>
        </div>
      </div>
    </section>

    <!-- NOTIFY TAB -->
    <section id="tabNotify" class="tab-content">
      <div class="grid">
        <!-- LEFT: Notify + Latest + Tools -->
        <div style="display:flex; flex-direction:column; gap:20px;">
          <!-- Notify panel -->
          <div class="panel">
            <div class="panel-title">Notify Channels</div>
            <div class="panel-caption">
              Notifications are device-driven. Select which Notify IDs to decode and plot.
              Notify decoding uses <code>notify_config.json</code> formulas only (not <code>readFormula</code>).
              <br> If the underlying variable has a <code>valueMap</code>, labels are used when displaying values.
            </div>
            <div id="notifyListenContainer" class="small"></div>
          </div>

          <!-- Latest values -->
          <div class="panel">
            <div class="panel-title">Latest Values</div>
            <div class="panel-caption">
              Last received value for each variable (from notify/read/write).
            </div>
            <div id="latestValuesContainer"></div>
          </div>

          <!-- Tools -->
          <div class="panel">
            <div class="panel-title">Tools & Logging</div>
            <div class="panel-caption">
              CSV logging is per frame. Notify logs are grouped by Notify ID.
            </div>
            <button id="downloadLogBtn" class="btn btn-outline" style="width:100%; margin-bottom:8px;">
              Download CSV Logs
            </button>
            <button id="clearValueLogBtn" class="btn btn-outline" style="width:100%; margin-bottom:8px;">
              Clear CSV Logs
            </button>
            <button id="clearChartBtn" class="btn btn-outline" style="width:100%; margin-bottom:8px;">
              Reset Chart
            </button>
            <button id="clearLatestBtn" class="btn btn-outline" style="width:100%;">
              Clear Latest Values
            </button>
            <div style="margin-top:8px; font-size:0.78rem; color:var(--text-muted);">
              <span id="logInfo"></span>
            </div>
          </div>
        </div>

        <!-- RIGHT: Plot -->
        <div class="panel">
          <div class="panel-title">Live Plot</div>
          <div class="panel-caption">
            Variables are plotted as separate datasets (x = time, y = value).
          </div>
          <div id="plotVarContainer" style="margin-bottom:10px;"></div>
          <canvas id="dataChart" height="260"></canvas>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    /************************************************************
     * PROTOCOL CONFIG
     ************************************************************/
    const PROTOCOL = {
      SOF: 0xAA,
      EOF: 0x55,
      lenIncludesType: true, // LEN = TYPE + PAYLOAD length
      useCRC: true,
      crcAlgorithm: 'xor8'
    };

    const CMD_READ_VAR      = 0x01;
    const CMD_WRITE_VAR     = 0x02;
    const CMD_READ_RESPONSE = 0x81;
    const CMD_NOTIFY_DATA   = 0x82;

    /************************************************************
     * GLOBAL STATE
     ************************************************************/
    let VARIABLE_DB = [];
    let NOTIFY_CONFIG = [];

    // Tab-specific variable arrays
    let READ_VARS = [];
    let WRITE_VARS = [];

    // Read/Write logs (per frame)
    const readWriteLog = []; // { time, kind, values: { [varId]: {name, value, unit} } }

    // Notify logs (per frame): notifyId -> [ { time, values: { [varId]: value } } ]
    const notifyLogs = new Map();

    function getTotalSampleCount() {
      let total = readWriteLog.length;
      notifyLogs.forEach(arr => { total += arr.length; });
      return total;
    }

    function updateSampleCount() {
      if (logInfo) {
        logInfo.textContent = `${getTotalSampleCount()} samples`;
      }
    }

    // Latest values: varId -> { value, unit, time }
    const latestValues = new Map();

    // Notify listen: notifyId -> boolean
    const notifyListenState = new Map();

    // Serial
    let port = null;
    let reader = null;
    let keepReading = false;

    // Buffers
    let rxBuffer = [];

    // Chart
    let dataChart;
    const datasets = [];
    const MAX_POINTS = 300;
    const t0 = performance.now();

    // Variable row buttons
    let varReadButtons = [];
    let varWriteButtons = [];

    /************************************************************
     * DOM ELEMENTS
     ************************************************************/
    const statusDot   = document.getElementById("statusDot");
    const statusText  = document.getElementById("statusText");
    const baudSelect  = document.getElementById("baudRate");
    const connectBtn  = document.getElementById("connectBtn");
    const disconnectBtn = document.getElementById("disconnectBtn");

    const tabReadBtn   = document.getElementById("tabReadBtn");
    const tabWriteBtn  = document.getElementById("tabWriteBtn");
    const tabNotifyBtn = document.getElementById("tabNotifyBtn");
    const tabRead      = document.getElementById("tabRead");
    const tabWrite     = document.getElementById("tabWrite");
    const tabNotify    = document.getElementById("tabNotify");

    const varTableReadContainer  = document.getElementById("varTableReadContainer");
    const varTableWriteContainer = document.getElementById("varTableWriteContainer");
    const readAllBtn             = document.getElementById("readAllBtn");

    const latestValuesContainer = document.getElementById("latestValuesContainer");
    const notifyListenContainer = document.getElementById("notifyListenContainer");
    const plotVarContainer      = document.getElementById("plotVarContainer");
    const rxLog                 = document.getElementById("rxLog");
    const logInfo               = document.getElementById("logInfo");

    const clearRxBtn        = document.getElementById("clearRxBtn");
    const clearValueLogBtn  = document.getElementById("clearValueLogBtn");
    const clearChartBtn     = document.getElementById("clearChartBtn");
    const clearLatestBtn    = document.getElementById("clearLatestBtn");
    const downloadLogBtn    = document.getElementById("downloadLogBtn");

    /************************************************************
     * TABS
     ************************************************************/
    function showTab(tab) {
      tabRead.classList.remove("active");
      tabWrite.classList.remove("active");
      tabNotify.classList.remove("active");
      tabReadBtn.classList.remove("active");
      tabWriteBtn.classList.remove("active");
      tabNotifyBtn.classList.remove("active");

      if (tab === "read") {
        tabRead.classList.add("active");
        tabReadBtn.classList.add("active");
      } else if (tab === "write") {
        tabWrite.classList.add("active");
        tabWriteBtn.classList.add("active");
      } else {
        tabNotify.classList.add("active");
        tabNotifyBtn.classList.add("active");
      }
    }

    tabReadBtn.onclick   = () => showTab("read");
    tabWriteBtn.onclick  = () => showTab("write");
    tabNotifyBtn.onclick = () => showTab("notify");

    /************************************************************
     * CONFIG LOAD
     ************************************************************/
    async function loadConfigs() {
      try {
        const [varRes, notifyRes] = await Promise.all([
          fetch("variables.json"),
          fetch("notify_config.json")
        ]);

        VARIABLE_DB = await varRes.json();
        const notifyJson = await notifyRes.json();
        NOTIFY_CONFIG = notifyJson.notifyCases || [];

        computeTabVariables();
        initVarTables();
        initLatestValuesUI();
        initNotifyUI();
        initChart();
      } catch (e) {
        console.error("Failed to load configs:", e);
        alert("Failed to load variables.json or notify_config.json");
      }
    }

    function inTab(v, tabName) {
      if (!v.tabs || !Array.isArray(v.tabs)) {
        // No tabs specified → available in all tabs (backward compatible)
        return true;
      }
      return v.tabs.includes(tabName);
    }

    function computeTabVariables() {
      READ_VARS  = VARIABLE_DB.filter(v => inTab(v, "read"));
      WRITE_VARS = VARIABLE_DB.filter(v => inTab(v, "write"));
    }

    loadConfigs();

    /************************************************************
     * HELPERS
     ************************************************************/
    function getVarById(id) {
      return VARIABLE_DB.find(v => v.id === id);
    }

    function getNotifyCaseById(id) {
      return NOTIFY_CONFIG.find(c => c.id === id);
    }

    function setConnectedState(isConnected, info = "") {
      if (isConnected) {
        statusDot.classList.add("connected");
        statusText.innerHTML = `<strong>Connected</strong> <span style="color:#94a3b8;">(${info})</span>`;
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
      } else {
        statusDot.classList.remove("connected");
        statusText.innerHTML = `<strong>Disconnected</strong>`;
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
      }

      readAllBtn.disabled = !isConnected;
      varReadButtons.forEach(btn => btn.disabled = !isConnected);
      varWriteButtons.forEach(btn => btn.disabled = !isConnected);
    }

    function crcXor8(bytes, startIdx, endIdx) {
      let crc = 0;
      for (let i = startIdx; i <= endIdx; i++) {
        crc ^= bytes[i];
      }
      return crc & 0xFF;
    }

    function computeCRC(frame, startIdx, endIdx) {
      if (!PROTOCOL.useCRC) return 0;
      switch (PROTOCOL.crcAlgorithm) {
        case "xor8":
        default:
          return crcXor8(frame, startIdx, endIdx);
      }
    }

    // Build: SOF | LEN | TYPE | PAYLOAD... | CRC | EOF
    function buildFrame(type, payloadBytes) {
      const payloadLen = payloadBytes.length;
      const lenField = PROTOCOL.lenIncludesType ? (1 + payloadLen) : payloadLen;
      const frameLen = 1 + 1 + 1 + payloadLen + 1 + 1;
      const frame = new Uint8Array(frameLen);
      let i = 0;

      frame[i++] = PROTOCOL.SOF;
      frame[i++] = lenField;
      frame[i++] = type;
      payloadBytes.forEach(b => frame[i++] = b);

      const crc = computeCRC(frame, 1, 1 + lenField);
      frame[i++] = crc;
      frame[i++] = PROTOCOL.EOF;

      return frame;
    }

    function encodeValueBytes(vDef, jsValue, endianness = "lsbFirst") {
      const fmt   = vDef.format || "int16";
      const scale = vDef.scale ?? 1.0;

      if (fmt === "float32") {
        const val = jsValue / scale;
        const buf = new ArrayBuffer(4);
        const view = new DataView(buf);
        view.setFloat32(0, val, false);
        let arr = [
          view.getUint8(0),
          view.getUint8(1),
          view.getUint8(2),
          view.getUint8(3)
        ];
        if (endianness === "lsbFirst") arr = arr.reverse();
        return arr;
      }

      let raw = Math.round(jsValue / scale);
      let bytes = [];

      if (fmt === "int16" || fmt === "uint16") {
        let v = raw & 0xFFFF;
        bytes = [(v & 0xFF), (v >> 8) & 0xFF];
      } else if (fmt === "int32" || fmt === "uint32") {
        let v = raw >>> 0;
        bytes = [
          v & 0xFF,
          (v >> 8) & 0xFF,
          (v >> 16) & 0xFF,
          (v >> 24) & 0xFF
        ];
      } else {
        let v = raw & 0xFFFF;
        bytes = [(v & 0xFF), (v >> 8) & 0xFF];
      }

      if (endianness === "msbFirst") bytes = bytes.slice().reverse();
      return bytes;
    }

    function decodeValueBytes(vDef, bytes, endianness = "lsbFirst") {
      const fmt    = vDef.format || "int16";
      const signed = vDef.signed ?? true;
      const scale  = vDef.scale ?? 1.0;

      let arr = Array.from(bytes);
      if (endianness === "lsbFirst") arr = arr.slice().reverse();

      let raw = 0;

      if (fmt === "int16" || fmt === "uint16") {
        if (arr.length < 2) return null;
        raw = (arr[0] << 8) | arr[1];
        if ((fmt === "int16" || signed) && (raw & 0x8000)) {
          raw -= 0x10000;
        }
      } else if (fmt === "int32" || fmt === "uint32") {
        if (arr.length < 4) return null;
        raw = (arr[0] << 24) | (arr[1] << 16) | (arr[2] << 8) | arr[3];
        if ((fmt === "int32" || signed) && (raw & 0x80000000)) {
          raw = raw | 0xFFFFFFFF00000000;
        }
      } else if (fmt === "float32") {
        if (arr.length < 4) return null;
        const buf = new ArrayBuffer(4);
        const view = new DataView(buf);
        arr.forEach((b, i) => view.setUint8(i, b));
        const fval = view.getFloat32(0, false);
        return fval * scale;
      } else {
        raw = 0;
        arr.forEach(b => { raw = (raw << 8) | b; });
      }

      return raw * scale;
    }

    // Generic formula evaluator for READ and NOTIFY:
    // B0 = first data byte of payload segment, B1 = second, etc.
    function evaluateFormula(formula, dataBytes) {
      if (!formula) return null;
      let expr = formula.replace(/B(\d+)/gi, (_, idx) => ` (b[${parseInt(idx,10)}] ?? 0) `);

      if (!/^[0-9+\-*/().,\s b\[\]?<>!=&|^%]*$/i.test(expr)) {
        console.warn("Unsafe characters in formula:", formula);
        return null;
      }

      try {
        const fn = new Function("b", "return " + expr + ";");
        const val = fn(dataBytes);
        if (typeof val === "number" && isFinite(val)) {
          return val;
        }
      } catch (e) {
        console.warn("Error evaluating formula:", formula, e);
      }
      return null;
    }

    // Map numeric value to label using valueMap (if available)
    function mapValueLabel(vDef, numericValue) {
      if (!vDef || !vDef.valueMap) return null;
      const key = String(numericValue);
      if (Object.prototype.hasOwnProperty.call(vDef.valueMap, key)) {
        return vDef.valueMap[key];
      }
      return null;
    }

    // Only updates UI + chart. Logging is done by frame handlers.
    function applyDecodedValue(kind, varId, numericValue, meta = {}) {
      const v = getVarById(varId);
      if (!v) return;
      const unit = v.unit || "";

      const label = mapValueLabel(v, numericValue);
      const displayStr = label
        ? `${label} (${numericValue}${unit ? " " + unit : ""})`
        : `${numericValue}${unit ? " " + unit : ""}`;

      // Latest values (Notify tab)
      const latestSlot = document.getElementById(`latest-${varId}`);
      if (latestSlot) latestSlot.textContent = displayStr;

      // Read tab: value next to read row
      const readSpan = document.getElementById(`read-val-${varId}`);
      if (readSpan && (kind === "READ" || kind === "WRITE")) {
        readSpan.textContent = displayStr;
      }

      // Write tab: value next to write row
      const writeSpan = document.getElementById(`write-val-${varId}`);
      if (writeSpan && (kind === "READ" || kind === "WRITE" || kind === "NOTIFY")) {
        writeSpan.textContent = displayStr;
      }

      // Chart (Notify tab) always uses numeric
      addChartPoint(varId, numericValue);
    }

    /************************************************************
     * UI INIT
     ************************************************************/
    function initVarTables() {
      varTableReadContainer.innerHTML = "";
      varTableWriteContainer.innerHTML = "";
      varReadButtons = [];
      varWriteButtons = [];

      // READ TAB TABLE
      READ_VARS.forEach(v => {
        const row = document.createElement("div");
        row.className = "var-row";

        const left = document.createElement("div");
        left.className = "var-row-left";

        const name = document.createElement("div");
        name.className = "var-row-name";
        name.textContent = v.name;

        const meta = document.createElement("div");
        meta.className = "var-row-meta";
        const unit = v.unit ? `, ${v.unit}` : "";
        meta.textContent = `ID 0x${v.id.toString(16)} · ${v.format || "int16"}${unit}`;

        left.appendChild(name);
        left.appendChild(meta);

        const right = document.createElement("div");
        right.className = "var-row-right";

        const readBtn = document.createElement("button");
        readBtn.textContent = "Read";
        readBtn.className = "btn btn-outline var-read-btn";
        readBtn.disabled = true;
        readBtn.onclick = () => sendReadVar(v);

        const valueSpan = document.createElement("div");
        valueSpan.className = "var-row-value";
        valueSpan.id = `read-val-${v.id}`;
        valueSpan.textContent = "—";

        right.appendChild(readBtn);
        right.appendChild(valueSpan);

        row.appendChild(left);
        row.appendChild(right);

        varTableReadContainer.appendChild(row);
        varReadButtons.push(readBtn);
      });

      // WRITE TAB TABLE
      WRITE_VARS.forEach(v => {
        const row = document.createElement("div");
        row.className = "var-row";

        const left = document.createElement("div");
        left.className = "var-row-left";

        const name = document.createElement("div");
        name.className = "var-row-name";
        name.textContent = v.name;

        const meta = document.createElement("div");
        meta.className = "var-row-meta";
        const unit = v.unit ? `, ${v.unit}` : "";
        meta.textContent = `ID 0x${v.id.toString(16)} · ${v.format || "int16"}${unit}`;

        left.appendChild(name);
        left.appendChild(meta);

        const right = document.createElement("div");
        right.className = "var-row-right";

        const input = document.createElement("input");
        input.type = "number";
        input.placeholder = "value";
        input.id = `var-write-${v.id}`;

        const writeBtn = document.createElement("button");
        writeBtn.textContent = "Write";
        writeBtn.className = "btn btn-outline var-write-btn";
        writeBtn.disabled = true;
        writeBtn.onclick = () => sendWriteVar(v, input.value);

        const valueSpan = document.createElement("div");
        valueSpan.className = "var-row-value";
        valueSpan.id = `write-val-${v.id}`;
        valueSpan.textContent = "—";

        right.appendChild(input);
        right.appendChild(writeBtn);
        right.appendChild(valueSpan);

        row.appendChild(left);
        row.appendChild(right);

        varTableWriteContainer.appendChild(row);
        varWriteButtons.push(writeBtn);
      });
    }

    function initLatestValuesUI() {
      latestValuesContainer.innerHTML = "";
      latestValues.clear();

      VARIABLE_DB.forEach(v => {
        const row = document.createElement("div");
        row.className = "latest-row";

        const left = document.createElement("div");
        left.innerHTML =
          `<strong>${v.name}</strong> <span style="color:#94a3b8;">(0x${v.id.toString(16)})</span>`;

        const right = document.createElement("div");
        right.id = `latest-${v.id}`;
        right.style.color = "#94a3b8";
        right.textContent = "—";

        row.appendChild(left);
        row.appendChild(right);
        latestValuesContainer.appendChild(row);

        latestValues.set(v.id, { value: null, unit: v.unit || "", time: null });
      });
    }

    function initNotifyUI() {
      notifyListenContainer.innerHTML = "";
      notifyListenState.clear();

      NOTIFY_CONFIG.forEach(cfg => {
        const label = document.createElement("label");
        label.className = "checkbox-pill";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = !!cfg.enabledByDefault;
        cb.dataset.notifyId = cfg.id;
        cb.onchange = () => {
          notifyListenState.set(cfg.id, cb.checked);
        };

        notifyListenState.set(cfg.id, !!cfg.enabledByDefault);

        label.appendChild(cb);
        label.appendChild(
          document.createTextNode(`ID ${cfg.id} – ${cfg.name || "Notify"}`)
        );
        notifyListenContainer.appendChild(label);
      });
    }

    function initChart() {
      const ctx = document.getElementById("dataChart")?.getContext("2d");
      if (!ctx) return;

      VARIABLE_DB.forEach((v, idx) => {
        datasets.push({
          label: v.name,
          varId: v.id,
          data: [],
          borderColor: getColor(idx),
          borderWidth: 1.5,
          pointRadius: 0,
          hidden: idx !== 0,
          parsing: false
        });

        const label = document.createElement("label");
        label.className = "checkbox-pill";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = (idx === 0);
        cb.dataset.varId = v.id;
        cb.onchange = () => {
          const ds = datasets.find(d => d.varId === v.id);
          ds.hidden = !cb.checked;
          dataChart.update();
        };
        label.appendChild(cb);
        label.appendChild(document.createTextNode(v.name));
        plotVarContainer.appendChild(label);
      });

      dataChart = new Chart(ctx, {
        type: "line",
        data: { datasets },
        options: {
          animation: false,
          responsive: true,
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Time (s)" },
              ticks: { color: "#94a3b8" },
              grid: { color: "rgba(148,163,184,0.15)" }
            },
            y: {
              title: { display: true, text: "Value" },
              ticks: { color: "#94a3b8" },
              grid: { color: "rgba(148,163,184,0.18)" }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: "#e5e7eb",
                font: { size: 11 }
              }
            }
          }
        }
      });
    }

    function getColor(i) {
      const palette = ["#3b82f6", "#22c55e", "#ef4444", "#eab308", "#a855f7", "#14b8a6"];
      return palette[i % palette.length];
    }

    function addChartPoint(varId, value) {
      const ds = datasets.find(d => d.varId === varId);
      if (!ds) return;
      const t = (performance.now() - t0) / 1000;
      ds.data.push({ x: t, y: value });
      if (ds.data.length > MAX_POINTS) ds.data.shift();
      if (dataChart) dataChart.update("none");
    }

    /************************************************************
     * SERIAL HANDLING
     ************************************************************/
    async function connectSerial() {
      if (!("serial" in navigator)) {
        alert("Web Serial API not supported in this browser.");
        return;
      }
      try {
        port = await navigator.serial.requestPort();
        const baud = parseInt(baudSelect.value, 10);
        await port.open({ baudRate: baud, dataBits: 8, stopBits: 1, parity: "none" });

        setConnectedState(true, `baud ${baud}`);
        keepReading = true;
        readLoop();
      } catch (e) {
        console.error("Failed to open port:", e);
        alert("Failed to open serial port");
      }
    }

    async function readLoop() {
      if (!port.readable) return;
      reader = port.readable.getReader();
      try {
        while (keepReading) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value && value.length > 0) handleIncomingBytes(value);
        }
      } catch (e) {
        console.error("Read error:", e);
      } finally {
        if (reader) reader.releaseLock();
        reader = null;
        setConnectedState(false);
      }
    }

    async function disconnectSerial() {
      try {
        keepReading = false;
        if (reader) {
          await reader.cancel().catch(() => {});
          reader.releaseLock();
          reader = null;
        }
        if (port) {
          await port.close();
          port = null;
        }
      } catch (e) {
        console.error("Disconnect error:", e);
      } finally {
        setConnectedState(false);
      }
    }

    async function sendFrame(frame) {
      if (!port || !port.writable) {
        alert("Not connected");
        return;
      }
      const writer = port.writable.getWriter();
      try {
        await writer.write(frame);
      } catch (e) {
        console.error("Write error:", e);
      } finally {
        writer.releaseLock();
      }
    }

    connectBtn.addEventListener("click", connectSerial);
    disconnectBtn.addEventListener("click", disconnectSerial);

    /************************************************************
     * RX PARSING
     ************************************************************/
    function handleIncomingBytes(chunk) {
      // Raw hex log
      const hexLine = Array.from(chunk)
        .map(b => b.toString(16).padStart(2, "0"))
        .join(" ");
      rxLog.value += hexLine + "\n";
      rxLog.scrollTop = rxLog.scrollHeight;

      // Accumulate for framing
      for (const b of chunk) rxBuffer.push(b);
      parseFramesFromBuffer();
    }

    function parseFramesFromBuffer() {
      const MIN_FRAME = 5; // SOF + LEN + TYPE + CRC + EOF

      while (rxBuffer.length >= MIN_FRAME) {
        const sofIndex = rxBuffer.indexOf(PROTOCOL.SOF);
        if (sofIndex === -1) {
          rxBuffer = [];
          return;
        }
        if (sofIndex > 0) {
          rxBuffer = rxBuffer.slice(sofIndex);
        }
        if (rxBuffer.length < MIN_FRAME) return;

        const lenField = rxBuffer[1];
        const payloadLen = PROTOCOL.lenIncludesType ? (lenField - 1) : lenField;
        if (payloadLen < 0) {
          rxBuffer.shift();
          continue;
        }

        const totalFrameLen = 1 + 1 + 1 + payloadLen + 1 + 1;
        if (rxBuffer.length < totalFrameLen) return;

        const frame = rxBuffer.slice(0, totalFrameLen);
        rxBuffer = rxBuffer.slice(totalFrameLen);

        if (frame[frame.length - 1] !== PROTOCOL.EOF) {
          console.warn("Bad EOF", frame);
          continue;
        }

        const crcReceived = frame[frame.length - 2];
        const crcComputed = computeCRC(frame, 1, 1 + lenField);
        if (PROTOCOL.useCRC && crcReceived !== crcComputed) {
          console.warn("CRC mismatch");
          continue;
        }

        const type = frame[2];
        const payloadStart = 3;
        const payloadEnd = payloadStart + payloadLen;
        const payload = frame.slice(payloadStart, payloadEnd);

        interpretFrame(type, payload);
      }
    }

    function interpretFrame(type, payload) {
      if (type === CMD_READ_RESPONSE) {
        handleReadResponse(payload);
      } else if (type === CMD_NOTIFY_DATA) {
        handleNotifyData(payload);
      } else {
        // unknown type
      }
    }

    // READ_RESPONSE: [varId, data...]
    function handleReadResponse(payload) {
      if (payload.length < 2) return;
      const varId = payload[0];
      const vDef = getVarById(varId);
      if (!vDef) return;

      const dataBytes = payload.slice(1);

      let value;
      if (vDef.readFormula) {
        // Use formula for read decoding (does NOT affect write/notify)
        value = evaluateFormula(vDef.readFormula, dataBytes);
      } else {
        // Fallback to standard decode using format/scale
        value = decodeValueBytes(vDef, dataBytes, "lsbFirst");
      }

      if (value === null || value === undefined) return;

      applyDecodedValue("READ", varId, value);

      const time = new Date().toISOString();
      const values = {};
      values[String(varId)] = {
        name: vDef.name,
        value,
        unit: vDef.unit || ""
      };
      readWriteLog.push({
        time,
        kind: "READ",
        values
      });
      updateSampleCount();
    }

    // NOTIFY_DATA: [notifyId, data...]
    function handleNotifyData(payload) {
      if (payload.length < 1) return;
      const notifyId = payload[0];
      const dataBytes = payload.slice(1);

      if (!notifyListenState.get(notifyId)) return;

      const cfg = getNotifyCaseById(notifyId);
      if (!cfg || !cfg.variables) return;

      const time = new Date().toISOString();
      const rowValues = {};

      cfg.variables.forEach(field => {
        const vDef = getVarById(field.varId);
        if (!vDef) return;

        let value = null;

        if (field.formula) {
          // Notify-specific formula from notify_config.json
          value = evaluateFormula(field.formula, dataBytes);
        } else {
          const start = field.startByte ?? 0;
          const len   = field.length    ?? 2;
          const end   = start + len;
          if (start < 0 || end > dataBytes.length) return;

          const slice = dataBytes.slice(start, end);
          const endianness = field.endianness || "lsbFirst";
          value = decodeValueBytes(vDef, slice, endianness);
        }

        if (value === null || value === undefined) return;

        applyDecodedValue("NOTIFY", vDef.id, value, { notifyId });

        rowValues[String(vDef.id)] = value;
      });

      if (Object.keys(rowValues).length === 0) return;

      if (!notifyLogs.has(notifyId)) {
        notifyLogs.set(notifyId, []);
      }
      notifyLogs.get(notifyId).push({
        time,
        values: rowValues
      });

      updateSampleCount();
    }

    /************************************************************
     * MULTI READ / WRITE
     ************************************************************/
    async function sendReadVar(v) {
      const span = document.getElementById(`read-val-${v.id}`);
      if (span) span.textContent = "--";

      const payload = [v.id];
      await sendFrame(buildFrame(CMD_READ_VAR, payload));
    }

    async function sendWriteVar(v, valStr) {
      const val = parseFloat(valStr);
      if (Number.isNaN(val)) {
        alert(`Enter a numeric value for ${v.name}`);
        return;
      }
      const endianness = v.endianness || "lsbFirst";
      const dataBytes = encodeValueBytes(v, val, endianness);
      const payload = [v.id, ...dataBytes];
      await sendFrame(buildFrame(CMD_WRITE_VAR, payload));

      applyDecodedValue("WRITE", v.id, val);

      const time = new Date().toISOString();
      const values = {};
      values[String(v.id)] = {
        name: v.name,
        value: val,
        unit: v.unit || ""
      };
      readWriteLog.push({
        time,
        kind: "WRITE",
        values
      });
      updateSampleCount();
    }

    readAllBtn.onclick = async () => {
      for (const v of READ_VARS) {
        await sendReadVar(v);
      }
    };

    /************************************************************
     * TOOLS & CSV DOWNLOAD
     ************************************************************/
    clearRxBtn.onclick = () => {
      rxLog.value = "";
      rxBuffer = [];
    };

    clearValueLogBtn.onclick = () => {
      readWriteLog.length = 0;
      notifyLogs.clear();
      updateSampleCount();
    };

    clearChartBtn.onclick = () => {
      datasets.forEach(ds => ds.data = []);
      if (dataChart) dataChart.update();
    };

    clearLatestBtn.onclick = () => {
      latestValues.forEach((v, varId) => {
        const slot = document.getElementById(`latest-${varId}`);
        if (slot) slot.textContent = "—";
      });
      latestValues.clear();
    };

    downloadLogBtn.onclick = () => {
      const total = getTotalSampleCount();
      if (!total) {
        alert("No data logged yet");
        return;
      }

      const ts = new Date().toISOString().replace(/[:.]/g, "-");

      // 1) Read/Write CSV
      if (readWriteLog.length) {
        const headers = ["time", "kind", ...VARIABLE_DB.map(v => JSON.stringify(v.name))];
        const lines = [headers.join(",")];

        readWriteLog.forEach(entry => {
          const row = [];
          row.push(entry.time);
          row.push(entry.kind);
          VARIABLE_DB.forEach(v => {
            const valObj = entry.values[String(v.id)];
            row.push(valObj ? valObj.value : "");
          });
          lines.push(row.join(","));
        });

        const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `read_write_log_${ts}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // 2) Notify CSVs (one per notifyId)
      notifyLogs.forEach((entries, notifyId) => {
        if (!entries.length) return;

        const cfg = getNotifyCaseById(notifyId);
        if (!cfg || !cfg.variables) return;

        const colDefs = cfg.variables.map(field => {
          const vDef = getVarById(field.varId);
          const baseName = field.nameOverride || (vDef ? vDef.name : `Var ${field.varId}`);
          return {
            varId: field.varId,
            key: String(field.varId),
            label: baseName
          };
        });

        const headers = ["time", "notifyId", ...colDefs.map(c => JSON.stringify(c.label))];
        const lines = [headers.join(",")];

        entries.forEach(entry => {
          const row = [];
          row.push(entry.time);
          row.push(notifyId);
          colDefs.forEach(c => {
            const v = entry.values[c.key];
            row.push(v !== undefined ? v : "");
          });
          lines.push(row.join(","));
        });

        const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `notify_${notifyId}_log_${ts}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    };
  </script>
</body>
</html>
